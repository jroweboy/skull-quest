;
; File generated by cc65 v 2.19 - Git 4f87c7c
;
	.fopt		compiler,"cc65 v 2.19 - Git 4f87c7c"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_set_vram_buffer
	.import		_one_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_get_pad_new
	.import		_pal_bg
	.import		_pal_spr
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_meta_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_vram_adr
	.import		_vram_fill
	.import		_vram_unrle
	.import		_memcpy
	.export		_forest_col_01
	.export		_forest_level_01
	.export		_title_screen
	.export		_HorizontalPaddleSpr
	.export		_VerticalPaddleSpr
	.export		_SkullSpr
	.export		_pal_forest_bg
	.export		_pal_spr_01
	.export		_level_list
	.export		_xCollisionDir
	.export		_yCollisionDir
	.export		_exp
	.export		_debug1
	.export		_debug2
	.export		_pad1
	.export		_pad1_new
	.export		_c_map
	.export		_collision_index
	.export		_backup_col_index
	.export		_backup_nt_index
	.export		_collision_mask
	.export		_i
	.export		_j
	.export		_temp
	.export		_temp2
	.export		_temp_x
	.export		_temp_y
	.export		_backup_col_type
	.export		_skull_launched
	.export		_p1_health
	.export		_p1_max_health
	.export		_game_state
	.export		_current_level
	.export		_is_soft_hit
	.export		_paddle_count
	.export		_paddles
	.export		_Skull
	.export		_update_health
	.export		_update_xp
	.export		_add_xp
	.export		_show_HUD
	.export		_show_title_screen
	.export		_show_game_over
	.export		_load_paddles
	.export		_load_level
	.export		_load_title_screen
	.export		_remove_brick
	.export		_hit_brick
	.export		_get_x_speed
	.export		_get_y_speed
	.export		_add_x_speed
	.export		_subtract_x_speed
	.export		_add_y_speed
	.export		_subtract_y_speed
	.export		_get_collision_type
	.export		_set_collision_data
	.export		_do_skull_tile_collision
	.export		_is_skull_collision_paddle
	.export		_is_paddle_collision_skull
	.export		_move_paddle
	.export		_check_paddle_collision
	.export		_check_main_input
	.export		_update_skull
	.export		_draw_sprites
	.export		_main

.segment	"DATA"

_level_list:
	.addr	_forest_level_01
	.addr	_forest_col_01
	.addr	_pal_forest_bg
_exp:
	.byte	$30,$30,$30,$30,$30,$30,$30,$30,$00
_Skull:
	.byte	$FF
	.byte	$FF
	.byte	$06
	.byte	$06
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$FF
	.byte	$64
	.byte	$64
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$40
	.byte	$FA

.segment	"RODATA"

_forest_col_01:
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$06
	.byte	$66
	.byte	$66
	.byte	$60
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$06
	.byte	$66
	.byte	$66
	.byte	$60
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$06
	.byte	$66
	.byte	$66
	.byte	$60
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$66
	.byte	$66
	.byte	$60
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$34
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$10
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$66
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$55
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$11
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$22
	.byte	$11
	.byte	$11
_forest_level_01:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$A0
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$08
	.byte	$08
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$19
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$08
	.byte	$09
	.byte	$08
	.byte	$09
	.byte	$08
	.byte	$09
	.byte	$08
	.byte	$09
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$18
	.byte	$18
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$18
	.byte	$19
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$19
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$10
	.byte	$01
	.byte	$07
	.byte	$08
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$10
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$10
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$10
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$10
	.byte	$18
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$19
	.byte	$10
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$10
	.byte	$01
	.byte	$09
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$10
	.byte	$08
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$10
	.byte	$01
	.byte	$02
	.byte	$11
	.byte	$01
	.byte	$11
	.byte	$10
	.byte	$01
	.byte	$02
	.byte	$18
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$01
	.byte	$02
	.byte	$08
	.byte	$09
	.byte	$10
	.byte	$10
	.byte	$11
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$08
	.byte	$09
	.byte	$05
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$08
	.byte	$18
	.byte	$19
	.byte	$09
	.byte	$10
	.byte	$01
	.byte	$11
	.byte	$08
	.byte	$18
	.byte	$19
	.byte	$09
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$08
	.byte	$18
	.byte	$08
	.byte	$09
	.byte	$19
	.byte	$09
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$08
	.byte	$18
	.byte	$08
	.byte	$09
	.byte	$19
	.byte	$09
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$18
	.byte	$08
	.byte	$18
	.byte	$19
	.byte	$09
	.byte	$19
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$18
	.byte	$08
	.byte	$18
	.byte	$19
	.byte	$09
	.byte	$19
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$08
	.byte	$18
	.byte	$08
	.byte	$09
	.byte	$19
	.byte	$09
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$14
	.byte	$15
	.byte	$08
	.byte	$18
	.byte	$08
	.byte	$09
	.byte	$19
	.byte	$09
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$08
	.byte	$18
	.byte	$19
	.byte	$09
	.byte	$10
	.byte	$01
	.byte	$11
	.byte	$08
	.byte	$18
	.byte	$19
	.byte	$09
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$01
	.byte	$02
	.byte	$06
	.byte	$07
	.byte	$10
	.byte	$10
	.byte	$11
	.byte	$01
	.byte	$0F
	.byte	$10
	.byte	$10
	.byte	$06
	.byte	$07
	.byte	$05
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$01
	.byte	$02
	.byte	$16
	.byte	$17
	.byte	$10
	.byte	$11
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$11
	.byte	$10
	.byte	$16
	.byte	$17
	.byte	$05
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$10
	.byte	$01
	.byte	$02
	.byte	$11
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$11
	.byte	$10
	.byte	$01
	.byte	$02
	.byte	$08
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$19
	.byte	$10
	.byte	$11
	.byte	$01
	.byte	$02
	.byte	$04
	.byte	$01
	.byte	$0F
	.byte	$11
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$18
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$10
	.byte	$11
	.byte	$01
	.byte	$15
	.byte	$10
	.byte	$08
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$19
	.byte	$10
	.byte	$11
	.byte	$01
	.byte	$15
	.byte	$10
	.byte	$18
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$10
	.byte	$11
	.byte	$01
	.byte	$15
	.byte	$10
	.byte	$08
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$19
	.byte	$10
	.byte	$11
	.byte	$01
	.byte	$15
	.byte	$10
	.byte	$18
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$09
	.byte	$10
	.byte	$01
	.byte	$17
	.byte	$08
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$19
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$1A
	.byte	$1B
	.byte	$18
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$01
	.byte	$1D
	.byte	$00
	.byte	$01
	.byte	$20
	.byte	$55
	.byte	$01
	.byte	$06
	.byte	$51
	.byte	$55
	.byte	$A5
	.byte	$A5
	.byte	$55
	.byte	$55
	.byte	$A5
	.byte	$A5
	.byte	$55
	.byte	$01
	.byte	$03
	.byte	$5A
	.byte	$5A
	.byte	$55
	.byte	$01
	.byte	$04
	.byte	$F5
	.byte	$01
	.byte	$03
	.byte	$55
	.byte	$01
	.byte	$02
	.byte	$65
	.byte	$5F
	.byte	$01
	.byte	$03
	.byte	$95
	.byte	$55
	.byte	$01
	.byte	$09
	.byte	$F5
	.byte	$01
	.byte	$05
	.byte	$55
	.byte	$05
	.byte	$01
	.byte	$06
	.byte	$05
	.byte	$01
	.byte	$00
_title_screen:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$FE
	.byte	$00
	.byte	$01
	.byte	$29
	.byte	$53
	.byte	$6B
	.byte	$75
	.byte	$6C
	.byte	$6C
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$51
	.byte	$75
	.byte	$65
	.byte	$73
	.byte	$74
	.byte	$00
	.byte	$01
	.byte	$B3
	.byte	$50
	.byte	$72
	.byte	$65
	.byte	$73
	.byte	$73
	.byte	$00
	.byte	$53
	.byte	$74
	.byte	$61
	.byte	$72
	.byte	$74
	.byte	$00
	.byte	$01
	.byte	$FE
	.byte	$00
	.byte	$01
	.byte	$32
	.byte	$54
	.byte	$68
	.byte	$65
	.byte	$00
	.byte	$6F
	.byte	$6C
	.byte	$64
	.byte	$00
	.byte	$67
	.byte	$61
	.byte	$6D
	.byte	$65
	.byte	$00
	.byte	$6D
	.byte	$61
	.byte	$6B
	.byte	$65
	.byte	$72
	.byte	$00
	.byte	$01
	.byte	$33
	.byte	$40
	.byte	$32
	.byte	$30
	.byte	$32
	.byte	$32
	.byte	$00
	.byte	$01
	.byte	$8B
	.byte	$00
	.byte	$01
	.byte	$00
_HorizontalPaddleSpr:
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$05
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$05
	.byte	$00
	.byte	$18
	.byte	$00
	.byte	$05
	.byte	$00
	.byte	$80
_VerticalPaddleSpr:
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$18
	.byte	$06
	.byte	$00
	.byte	$80
_SkullSpr:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$80
_pal_forest_bg:
	.byte	$0F
	.byte	$15
	.byte	$20
	.byte	$09
	.byte	$0F
	.byte	$29
	.byte	$1A
	.byte	$09
	.byte	$0F
	.byte	$08
	.byte	$17
	.byte	$27
	.byte	$0F
	.byte	$37
	.byte	$17
	.byte	$09
_pal_spr_01:
	.byte	$0F
	.byte	$20
	.byte	$15
	.byte	$12
	.byte	$0F
	.byte	$11
	.byte	$22
	.byte	$32
	.byte	$0F
	.byte	$13
	.byte	$23
	.byte	$33
	.byte	$0F
	.byte	$14
	.byte	$24
	.byte	$34

.segment	"BSS"

_xCollisionDir:
	.res	1,$00
_yCollisionDir:
	.res	1,$00
_debug1:
	.res	1,$00
_debug2:
	.res	1,$00
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_c_map:
	.res	368,$00
_collision_index:
	.res	2,$00
_backup_col_index:
	.res	2,$00
_backup_nt_index:
	.res	2,$00
_collision_mask:
	.res	1,$00
_i:
	.res	1,$00
_j:
	.res	1,$00
_temp:
	.res	1,$00
_temp2:
	.res	1,$00
_temp_x:
	.res	1,$00
_temp_y:
	.res	1,$00
_backup_col_type:
	.res	1,$00
_skull_launched:
	.res	1,$00
_p1_health:
	.res	1,$00
_p1_max_health:
	.res	1,$00
_game_state:
	.res	1,$00
_current_level:
	.res	1,$00
_is_soft_hit:
	.res	1,$00
_paddle_count:
	.res	1,$00
_paddles:
	.res	72,$00

; ---------------------------------------------------------------
; void __near__ update_health (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_health: near

.segment	"CODE"

;
; if (p1_health > 0) {
;
	lda     _p1_health
	beq     L000E
;
; for (i = 0; i < p1_max_health; ++i) {
;
	lda     #$00
	sta     _i
L000B:	lda     _i
	cmp     _p1_max_health
	bcs     L000A
;
; one_vram_buffer((i < p1_health) ? TILE_HEART_FULL : TILE_HEART_EMPTY, NTADR_A(i + 2, 2));
;
	cmp     _p1_health
	bcs     L000C
	lda     #$5B
	jmp     L000D
L000C:	lda     #$5C
L000D:	jsr     pusha
	ldx     #$00
	lda     _i
	clc
	adc     #$02
	bcc     L0009
	inx
L0009:	ora     #$40
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; for (i = 0; i < p1_max_health; ++i) {
;
	inc     _i
	jmp     L000B
;
; one_vram_buffer(TILE_HEART_EMPTY, NTADR_A(2, 2));
;
L000E:	lda     #$5C
	jsr     pusha
	ldx     #$20
	lda     #$42
	jmp     _one_vram_buffer
;
; }
;
L000A:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ update_xp (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_xp: near

.segment	"CODE"

;
; multi_vram_buffer_horz(exp, sizeof(exp), NTADR_A(12, 2));
;
	jsr     decsp3
	lda     #<(_exp)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_exp)
	sta     (sp),y
	lda     #$09
	ldy     #$00
	sta     (sp),y
	ldx     #$20
	lda     #$4C
	jmp     _multi_vram_buffer_horz

.endproc

; ---------------------------------------------------------------
; void __near__ add_xp (unsigned char value, unsigned char pos)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_add_xp: near

.segment	"CODE"

;
; void add_xp(unsigned char value, unsigned char pos) {
;
	jsr     pusha
;
; unsigned char result = exp[pos] + value - 0x30;
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     _exp,y
	sta     ptr1
	ldy     #$01
	lda     (sp),y
	clc
	adc     ptr1
	sec
	sbc     #$30
	jsr     pusha
;
; if (result > 9) {
;
	ldy     #$00
	lda     (sp),y
	cmp     #$0A
	bcc     L0004
;
; if (pos == TEN_MILLIONS) {
;
	iny
	lda     (sp),y
	bne     L000C
;
; result = 9;
;
	lda     #$09
	dey
;
; } else {
;
	jmp     L000B
;
; add_xp(1, pos - 1);
;
L000C:	tya
	jsr     pusha
	ldy     #$02
	lda     (sp),y
	sec
	sbc     #$01
	jsr     _add_xp
;
; result -= 10;
;
	ldy     #$00
	lda     (sp),y
	sec
	sbc     #$0A
L000B:	sta     (sp),y
;
; exp[pos] = 0x30 + result;
;
L0004:	lda     #<(_exp)
	ldx     #>(_exp)
	iny
	clc
	adc     (sp),y
	bcc     L0008
	inx
L0008:	sta     ptr1
	stx     ptr1+1
	dey
	lda     (sp),y
	clc
	adc     #$30
	sta     (ptr1),y
;
; update_xp();
;
	jsr     _update_xp
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ show_HUD (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_show_HUD: near

.segment	"CODE"

;
; vram_adr(0x23C0);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; vram_fill(0x00, 8);
;
	lda     #$00
	jsr     pusha
	tax
	lda     #$08
	jsr     _vram_fill
;
; update_health();
;
	jsr     _update_health
;
; update_xp();
;
	jsr     _update_xp
;
; one_vram_buffer(0x5d, NTADR_A(22, 2));
;
	lda     #$5D
	jsr     pusha
	ldx     #$20
	lda     #$56
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x5e, NTADR_A(23, 2));
;
	lda     #$5E
	jsr     pusha
	ldx     #$20
	lda     #$57
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x5f, NTADR_A(24, 2));
;
	lda     #$5F
	jsr     pusha
	ldx     #$20
	lda     #$58
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x7e, NTADR_A(23, 3));
;
	lda     #$7E
	jsr     pusha
	ldx     #$20
	lda     #$77
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x7f, NTADR_A(24, 3));
;
	lda     #$7F
	jsr     pusha
	ldx     #$20
	lda     #$78
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ show_title_screen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_show_title_screen: near

.segment	"CODE"

;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ show_game_over (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_show_game_over: near

.segment	"CODE"

;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ load_paddles (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_load_paddles: near

.segment	"CODE"

;
; switch (current_level) {
;
	lda     _current_level
;
; }
;
	jeq     L002D
	cmp     #$01
	jeq     L002E
	cmp     #$02
	jeq     L002E
	cmp     #$03
	jeq     L002E
	cmp     #$04
	jeq     L002E
	cmp     #$05
	jeq     L002E
	cmp     #$06
	jeq     L002E
	cmp     #$07
	jeq     L002E
	cmp     #$08
	jeq     L002E
	cmp     #$09
	jeq     L002E
	cmp     #$0A
	jeq     L002E
	cmp     #$0B
	beq     L002E
	cmp     #$0C
	beq     L002E
	cmp     #$0D
	beq     L002E
	cmp     #$0E
	beq     L002E
	cmp     #$0F
	beq     L002E
	cmp     #$10
	beq     L002E
	cmp     #$11
	beq     L002E
	cmp     #$12
	beq     L002E
	cmp     #$13
	beq     L002E
	cmp     #$14
	beq     L002E
	cmp     #$15
	beq     L002E
	cmp     #$16
	beq     L002E
	cmp     #$17
	beq     L002E
	cmp     #$18
	beq     L002E
	cmp     #$19
	beq     L002E
	cmp     #$1A
	beq     L002E
	cmp     #$1B
	beq     L002E
	cmp     #$1C
	beq     L002E
	cmp     #$1D
	beq     L002E
	cmp     #$1E
	beq     L002E
	cmp     #$1F
	beq     L002E
	cmp     #$20
	beq     L002E
	cmp     #$21
	beq     L002E
	jmp     L002E
;
; paddle_count = 2;
;
L002D:	lda     #$02
	sta     _paddle_count
;
; paddles[0].x = 0x75;
;
	lda     #$75
	sta     _paddles
;
; paddles[0].y = 0xCF;
;
	lda     #$CF
	sta     _paddles+1
;
; paddles[1].x = 0x75;
;
	lda     #$75
	sta     _paddles+18
;
; paddles[1].y = 0x50;
;
	lda     #$50
	sta     _paddles+19
;
; for (i = 0; i < paddle_count; ++i) {
;
L002E:	lda     #$00
	sta     _i
L002F:	lda     _i
	cmp     _paddle_count
	bcc     L0032
;
; }
;
	rts
;
; if (i < 2) {
;
L0032:	lda     _i
	cmp     #$02
	bcs     L0030
;
; paddles[i].width = 0x20;
;
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$20
	ldy     #$02
	sta     (ptr1),y
;
; paddles[i].height = 0x04;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$04
	ldy     #$03
	sta     (ptr1),y
;
; paddles[i].bbox_x = 0x02;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$02
	ldy     #$04
	sta     (ptr1),y
;
; paddles[i].bbox_y = 0x00;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
;
; } else {
;
	jmp     L0031
;
; paddles[i].width = 0x04;
;
L0030:	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$04
	ldy     #$02
	sta     (ptr1),y
;
; paddles[i].height = 0x20;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$20
	ldy     #$03
	sta     (ptr1),y
;
; paddles[i].bbox_x = 0x00;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$04
	sta     (ptr1),y
;
; paddles[i].bbox_y = 0x02;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$02
L0031:	ldy     #$05
	sta     (ptr1),y
;
; paddles[i].xSpeed = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$06
	sta     (ptr1),y
;
; paddles[i].ySpeed = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$07
	sta     (ptr1),y
;
; paddles[i].xDir = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$08
	sta     (ptr1),y
;
; paddles[i].yDir = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$09
	sta     (ptr1),y
;
; paddles[i].xSpeedFloat = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$0A
	sta     (ptr1),y
;
; paddles[i].ySpeedFloat = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$0B
	sta     (ptr1),y
;
; paddles[i].xVelocity = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$0E
	sta     (ptr1),y
;
; paddles[i].yVelocity = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$0F
	sta     (ptr1),y
;
; paddles[i].minSpeed = 0;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$00
	ldy     #$10
	sta     (ptr1),y
;
; paddles[i].maxSpeed = 250;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$FA
	ldy     #$11
	sta     (ptr1),y
;
; for (i = 0; i < paddle_count; ++i) {
;
	inc     _i
	jmp     L002F

.endproc

; ---------------------------------------------------------------
; void __near__ load_level (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_load_level: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(level_list[current_level]);
;
	ldx     #$00
	lda     _current_level
	asl     a
	bcc     L0005
	inx
	clc
L0005:	adc     #<(_level_list)
	sta     ptr1
	txa
	adc     #>(_level_list)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     _vram_unrle
;
; memcpy(c_map, level_list[current_level + 1], 368);
;
	lda     #<(_c_map)
	ldx     #>(_c_map)
	jsr     pushax
	ldx     #$00
	lda     _current_level
	clc
	adc     #$01
	bcc     L0002
	inx
L0002:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #<(_level_list)
	sta     ptr1
	lda     tmp1
	adc     #>(_level_list)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	ldx     #$01
	lda     #$70
	jsr     _memcpy
;
; load_paddles();
;
	jsr     _load_paddles
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; if (game_state == MAIN) {
;
	lda     _game_state
	cmp     #$01
	bne     L0003
;
; show_HUD();
;
	jsr     _show_HUD
;
; skull_launched = FALSE;
;
	lda     #$00
	sta     _skull_launched
;
; }
;
L0003:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ load_title_screen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_load_title_screen: near

.segment	"CODE"

;
; pal_bg((const char*)pal_forest_bg);
;
	lda     #<(_pal_forest_bg)
	ldx     #>(_pal_forest_bg)
	jsr     _pal_bg
;
; pal_spr(pal_spr_01);
;
	lda     #<(_pal_spr_01)
	ldx     #>(_pal_spr_01)
	jsr     _pal_spr
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(title_screen);
;
	lda     #<(_title_screen)
	ldx     #>(_title_screen)
	jsr     _vram_unrle
;
; game_state = TITLE;
;
	lda     #$00
	sta     _game_state
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ remove_brick (char tile_type)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_remove_brick: near

.segment	"CODE"

;
; void remove_brick(char tile_type) {
;
	jsr     pusha
;
; one_vram_buffer(tile_type, backup_nt_index);
;
	ldy     #$00
	lda     (sp),y
	jsr     pusha
	lda     _backup_nt_index
	ldx     _backup_nt_index+1
	jsr     _one_vram_buffer
;
; c_map[backup_col_index] &= backup_nt_index % 2 ? 0b11110000 : 0b00001111;
;
	lda     _backup_col_index
	clc
	adc     #<(_c_map)
	tay
	lda     _backup_col_index+1
	adc     #>(_c_map)
	tax
	tya
	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	lda     _backup_nt_index
	ldx     _backup_nt_index+1
	jsr     pushax
	ldx     #$00
	lda     #$02
	jsr     tosmoda0
	stx     tmp1
	ora     tmp1
	beq     L0002
	lda     #$F0
	jmp     L0003
L0002:	lda     #$0F
L0003:	jsr     tosanda0
	ldy     #$00
	jsr     staspidx
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ hit_brick (char tile_type)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hit_brick: near

.segment	"CODE"

;
; void hit_brick(char tile_type) {
;
	jsr     pusha
;
; remove_brick(tile_type);
;
	ldy     #$00
	lda     (sp),y
	jsr     _remove_brick
;
; is_soft_hit = FALSE;
;
	lda     #$00
	sta     _is_soft_hit
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; signed char __near__ get_x_speed (struct $anon-struct-0001 *actor)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_get_x_speed: near

.segment	"CODE"

;
; signed char get_x_speed(Actor* actor) {
;
	jsr     pushax
;
; actor->xSpeed = actor->xSpeedFloat >> 7;
;
	ldy     #$01
	lda     (sp),y
	sta     sreg+1
	dey
	lda     (sp),y
	sta     sreg
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	cmp     #$80
	ldy     #$06
	sta     (sreg),y
;
; actor->xRemain += actor->xSpeedFloat & 0b01111111;  // MODULO 128
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     ptr2
	stx     ptr2+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$0C
	lda     (ptr1),y
	sta     sreg
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	and     #$7F
	clc
	adc     sreg
	ldy     #$0C
	sta     (ptr2),y
;
; temp = 0;
;
	lda     #$00
	sta     _temp
;
; temp2 = 0;
;
	sta     _temp2
;
; if (actor->xRemain > 127) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0C
	lda     (ptr1),y
	cmp     #$80
	bcc     L0003
;
; actor->xRemain &= 0b01111111;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0C
	lda     (ptr1),y
	and     #$7F
	sta     (ptr1),y
;
; temp = 1;
;
	lda     #$01
	sta     _temp
;
; temp2 = ((actor->xVelocity > 40) || (actor->xVelocity % 2)) ? 1 : 0;
;
L0003:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0E
	lda     (ptr1),y
	cmp     #$29
	bcs     L000E
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0E
	lda     (ptr1),y
	and     #$01
	beq     L0010
L000E:	lda     #$01
L0010:	sta     _temp2
;
; if (actor->xVelocity) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0E
	lda     (ptr1),y
	beq     L0008
;
; --actor->xVelocity;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0E
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; return (actor->xSpeed + temp + temp2) * actor->xDir;
;
L0008:	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$06
	jsr     ldaidx
	clc
	adc     _temp
	bcc     L000D
	inx
	clc
L000D:	adc     _temp2
	bcc     L000B
	inx
L000B:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$08
	jsr     ldaidx
	jsr     tosmulax
	ldx     #$00
	cmp     #$80
	bcc     L0001
	dex
;
; }
;
L0001:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; signed char __near__ get_y_speed (struct $anon-struct-0001 *actor)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_get_y_speed: near

.segment	"CODE"

;
; signed char get_y_speed(Actor* actor) {
;
	jsr     pushax
;
; actor->ySpeed = actor->ySpeedFloat >> 7;
;
	ldy     #$01
	lda     (sp),y
	sta     sreg+1
	dey
	lda     (sp),y
	sta     sreg
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	cmp     #$80
	ldy     #$07
	sta     (sreg),y
;
; actor->yRemain += actor->ySpeedFloat & 0b01111111;  // MODULO 128
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     ptr2
	stx     ptr2+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$0D
	lda     (ptr1),y
	sta     sreg
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	and     #$7F
	clc
	adc     sreg
	ldy     #$0D
	sta     (ptr2),y
;
; temp = 0;
;
	lda     #$00
	sta     _temp
;
; temp2 = 0;
;
	sta     _temp2
;
; if (actor->yRemain > 127) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0D
	lda     (ptr1),y
	cmp     #$80
	bcc     L0003
;
; actor->yRemain &= 0b01111111;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0D
	lda     (ptr1),y
	and     #$7F
	sta     (ptr1),y
;
; temp = 1;
;
	lda     #$01
	sta     _temp
;
; temp2 = ((actor->yVelocity > 40) || (actor->yVelocity % 2)) ? 1 : 0;
;
L0003:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0F
	lda     (ptr1),y
	cmp     #$29
	bcs     L000E
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0F
	lda     (ptr1),y
	and     #$01
	beq     L0010
L000E:	lda     #$01
L0010:	sta     _temp2
;
; if (actor->yVelocity) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0F
	lda     (ptr1),y
	beq     L0008
;
; --actor->yVelocity;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0F
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; return (actor->ySpeed + temp + temp2) * actor->yDir;
;
L0008:	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$07
	jsr     ldaidx
	clc
	adc     _temp
	bcc     L000D
	inx
	clc
L000D:	adc     _temp2
	bcc     L000B
	inx
L000B:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$09
	jsr     ldaidx
	jsr     tosmulax
	ldx     #$00
	cmp     #$80
	bcc     L0001
	dex
;
; }
;
L0001:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ add_x_speed (unsigned char val, struct $anon-struct-0001 *actor)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_add_x_speed: near

.segment	"CODE"

;
; void add_x_speed(unsigned char val, Actor* actor) {
;
	jsr     pushax
;
; temp = actor->xSpeedFloat;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	sta     _temp
;
; actor->xSpeedFloat += val;
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$0A
	lda     (ptr1),y
	sta     ptr1
	ldy     #$02
	lda     (sp),y
	clc
	adc     ptr1
	ldy     #$0A
	sta     (sreg),y
;
; if (actor->xSpeedFloat > actor->maxSpeed || actor->xSpeedFloat < temp) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	sta     sreg
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$11
	lda     (ptr1),y
	cmp     sreg
	bcc     L0006
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	cmp     _temp
	bcs     L0002
;
; actor->xSpeedFloat = actor->maxSpeed;
;
L0006:	ldy     #$01
	lda     (sp),y
	sta     sreg+1
	dey
	lda     (sp),y
	sta     sreg
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$11
	lda     (ptr1),y
	ldy     #$0A
	sta     (sreg),y
;
; }
;
L0002:	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ subtract_x_speed (unsigned char val, struct $anon-struct-0001 *actor)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_subtract_x_speed: near

.segment	"CODE"

;
; void subtract_x_speed(unsigned char val, Actor* actor) {
;
	jsr     pushax
;
; temp = actor->xSpeedFloat;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	sta     _temp
;
; actor->xSpeedFloat -= val;
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$0A
	lda     (ptr1),y
	sec
	ldy     #$02
	sbc     (sp),y
	ldy     #$0A
	sta     (sreg),y
;
; if (actor->xSpeedFloat < actor->minSpeed || actor->xSpeedFloat > temp) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	sta     sreg
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$10
	lda     (ptr1),y
	cmp     sreg
	beq     L0005
	bcs     L0008
L0005:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	cmp     _temp
	beq     L0002
	bcc     L0002
;
; actor->xSpeedFloat = actor->minSpeed;
;
L0008:	ldy     #$01
	lda     (sp),y
	sta     sreg+1
	dey
	lda     (sp),y
	sta     sreg
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$10
	lda     (ptr1),y
	ldy     #$0A
	sta     (sreg),y
;
; }
;
L0002:	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ add_y_speed (unsigned char val, struct $anon-struct-0001 *actor)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_add_y_speed: near

.segment	"CODE"

;
; void add_y_speed(unsigned char val, Actor* actor) {
;
	jsr     pushax
;
; temp = actor->ySpeedFloat;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	sta     _temp
;
; actor->ySpeedFloat += val;
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$0B
	lda     (ptr1),y
	sta     ptr1
	ldy     #$02
	lda     (sp),y
	clc
	adc     ptr1
	ldy     #$0B
	sta     (sreg),y
;
; if (actor->ySpeedFloat > actor->maxSpeed || actor->ySpeedFloat < temp) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	sta     sreg
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$11
	lda     (ptr1),y
	cmp     sreg
	bcc     L0006
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	cmp     _temp
	bcs     L0002
;
; actor->ySpeedFloat = actor->maxSpeed;
;
L0006:	ldy     #$01
	lda     (sp),y
	sta     sreg+1
	dey
	lda     (sp),y
	sta     sreg
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$11
	lda     (ptr1),y
	ldy     #$0B
	sta     (sreg),y
;
; }
;
L0002:	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ subtract_y_speed (unsigned char val, struct $anon-struct-0001 *actor)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_subtract_y_speed: near

.segment	"CODE"

;
; void subtract_y_speed(unsigned char val, Actor* actor) {
;
	jsr     pushax
;
; temp = actor->ySpeedFloat;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	sta     _temp
;
; actor->ySpeedFloat -= val;
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$0B
	lda     (ptr1),y
	sec
	ldy     #$02
	sbc     (sp),y
	ldy     #$0B
	sta     (sreg),y
;
; if (actor->ySpeedFloat < actor->minSpeed || actor->ySpeedFloat > temp) {
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	sta     sreg
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$10
	lda     (ptr1),y
	cmp     sreg
	beq     L0005
	bcs     L0008
L0005:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	cmp     _temp
	beq     L0002
	bcc     L0002
;
; actor->ySpeedFloat = actor->minSpeed;
;
L0008:	ldy     #$01
	lda     (sp),y
	sta     sreg+1
	dey
	lda     (sp),y
	sta     sreg
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$10
	lda     (ptr1),y
	ldy     #$0B
	sta     (sreg),y
;
; }
;
L0002:	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; char __near__ get_collision_type (char param_x, char param_y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_get_collision_type: near

.segment	"CODE"

;
; char get_collision_type(char param_x, char param_y) {
;
	jsr     pusha
;
; collision_index = (param_x >> 4) + (((param_y >> 3) - 5) * 16);
;
	ldy     #$01
	lda     (sp),y
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	jsr     pusha0
	ldy     #$02
	lda     (sp),y
	lsr     a
	lsr     a
	lsr     a
	sec
	sbc     #$05
	bcs     L0002
	ldx     #$FF
L0002:	jsr     aslax4
	jsr     tosaddax
	sta     _collision_index
	stx     _collision_index+1
;
; return (param_x >> 3) % 2 ? c_map[collision_index] & 0x0F : c_map[collision_index] >> 4;
;
	ldy     #$01
	lda     (sp),y
	lsr     a
	lsr     a
	lsr     a
	jsr     pusha0
	lda     #$02
	jsr     tosmoda0
	stx     tmp1
	ora     tmp1
	beq     L0003
	lda     _collision_index
	sta     ptr1
	lda     _collision_index+1
	clc
	adc     #>(_c_map)
	sta     ptr1+1
	ldy     #<(_c_map)
	lda     (ptr1),y
	ldx     #$00
	and     #$0F
	jmp     L0005
L0003:	lda     _collision_index
	sta     ptr1
	lda     _collision_index+1
	clc
	adc     #>(_c_map)
	sta     ptr1+1
	ldy     #<(_c_map)
	lda     (ptr1),y
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	ldx     #$00
;
; }
;
L0005:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; char __near__ set_collision_data (char param_x, char param_y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_collision_data: near

.segment	"CODE"

;
; char set_collision_data(char param_x, char param_y) {
;
	jsr     pusha
;
; backup_nt_index = NTADR_A((param_x >> 3), (param_y >> 3));
;
	ldx     #$00
	lda     (sp,x)
	lsr     a
	lsr     a
	lsr     a
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ldx     tmp1
	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (sp),y
	lsr     a
	lsr     a
	lsr     a
	ora     ptr1
	sta     _backup_nt_index
	lda     ptr1+1
	ora     #$20
	sta     _backup_nt_index+1
;
; backup_col_type = get_collision_type(param_x, param_y);
;
	lda     (sp),y
	jsr     pusha
	ldy     #$01
	lda     (sp),y
	jsr     _get_collision_type
	sta     _backup_col_type
;
; backup_col_index = collision_index;
;
	lda     _collision_index+1
	sta     _backup_col_index+1
	lda     _collision_index
	sta     _backup_col_index
;
; return backup_col_type;
;
	ldx     #$00
	lda     _backup_col_type
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ do_skull_tile_collision (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_do_skull_tile_collision: near

.segment	"CODE"

;
; switch (backup_col_type) {
;
	lda     _backup_col_type
;
; }
;
	cmp     #$01
	bne     L001A
;
; }
;
	rts
;
; }
;
L001A:	cmp     #$02
	beq     L0005
	cmp     #$03
	beq     L0016
	cmp     #$04
	beq     L0017
	cmp     #$05
	jeq     L0018
	cmp     #$06
	jeq     L0019
	cmp     #$07
	bne     L001B
;
; }
;
	rts
;
; }
;
L001B:	cmp     #$08
	bne     L001C
;
; }
;
	rts
;
; }
;
L001C:	cmp     #$09
	bne     L001D
;
; }
;
	rts
;
; }
;
L001D:	cmp     #$0A
	beq     L0003
	cmp     #$0B
	beq     L0003
	cmp     #$0C
	beq     L0003
	cmp     #$0D
	beq     L0003
	cmp     #$0E
	beq     L0003
	cmp     #$0F
	beq     L0003
	rts
;
; if (p1_health) {
;
L0005:	lda     _p1_health
	beq     L0006
;
; --p1_health;
;
	dec     _p1_health
;
; update_health();
;
L0006:	jmp     _update_health
;
; remove_brick(TILE_BACK);
;
L0016:	lda     #$10
	jsr     _remove_brick
;
; ++backup_nt_index;
;
	inc     _backup_nt_index
	bne     L0008
	inc     _backup_nt_index+1
;
; hit_brick(TILE_BACK);
;
L0008:	lda     #$10
	jsr     _hit_brick
;
; add_xp(1, HUNDREDS);
;
	lda     #$01
	jsr     pusha
	lda     #$05
	jmp     _add_xp
;
; remove_brick(TILE_BACK);
;
L0017:	lda     #$10
	jsr     _remove_brick
;
; --backup_nt_index;
;
	lda     _backup_nt_index
	sec
	sbc     #$01
	sta     _backup_nt_index
	bcs     L000A
	dec     _backup_nt_index+1
;
; hit_brick(TILE_BACK);
;
L000A:	lda     #$10
	jsr     _hit_brick
;
; add_xp(1, HUNDREDS);
;
	lda     #$01
	jsr     pusha
	lda     #$05
	jmp     _add_xp
;
; hit_brick(0x11);
;
L0018:	lda     #$11
	jsr     _hit_brick
;
; add_xp(5, TENS);
;
	lda     #$05
	jsr     pusha
	lda     #$06
	jmp     _add_xp
;
; hit_brick(TILE_BACK_GRASS);
;
L0019:	lda     #$23
	jsr     _hit_brick
;
; is_soft_hit = TRUE;
;
	lda     #$01
	sta     _is_soft_hit
;
; break;
;
	rts
;
; }
;
L0003:	rts

.endproc

; ---------------------------------------------------------------
; char __near__ is_skull_collision_paddle (struct $anon-struct-0001 *paddle)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_is_skull_collision_paddle: near

.segment	"CODE"

;
; char is_skull_collision_paddle(Actor* paddle) {
;
	jsr     pushax
;
; return (temp_x < paddle->x + paddle->width + paddle->bbox_x &&
;
	lda     _temp_x
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1,x)
	sta     sreg
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L0007
	inx
L0007:	sta     sreg
	stx     sreg+1
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	clc
	adc     sreg
	ldx     sreg+1
	bcc     L0008
	inx
L0008:	jsr     tosicmp
	jpl     L0002
;
; temp_x + Skull.width > paddle->x + paddle->bbox_x &&
;
	ldx     #$00
	lda     _temp_x
	clc
	adc     _Skull+2
	bcc     L0005
	inx
L0005:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     sreg
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L0009
	inx
L0009:	jsr     tosicmp
	jmi     L0002
	jeq     L0002
;
; temp_y < paddle->y + paddle->height + paddle->bbox_y &&
;
	lda     _temp_y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	sta     sreg
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	iny
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L000A
	inx
L000A:	sta     sreg
	stx     sreg+1
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	lda     (ptr1),y
	clc
	adc     sreg
	ldx     sreg+1
	bcc     L000B
	inx
L000B:	jsr     tosicmp
	bpl     L0002
;
; temp_y + Skull.height > paddle->y + paddle->bbox_y);
;
	ldx     #$00
	lda     _temp_y
	clc
	adc     _Skull+3
	bcc     L0006
	inx
L0006:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	sta     sreg
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L000C
	inx
L000C:	jsr     tosicmp
	beq     L0002
	bpl     L0003
L0002:	ldx     #$00
	txa
	jmp     L000D
L0003:	lda     #$01
	ldx     #$00
;
; }
;
L000D:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; char __near__ is_paddle_collision_skull (struct $anon-struct-0001 *paddle)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_is_paddle_collision_skull: near

.segment	"CODE"

;
; char is_paddle_collision_skull(Actor* paddle) {
;
	jsr     pushax
;
; return (Skull.x + 7 > paddle->x + paddle->bbox_x &&
;
	ldx     #$00
	lda     _Skull
	clc
	adc     #$07
	bcc     L0002
	inx
L0002:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     sreg
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L0009
	inx
L0009:	jsr     tosicmp
	jmi     L0003
	jeq     L0003
;
; Skull.y + 7 > paddle->y + paddle->bbox_y &&
;
	ldx     #$00
	lda     _Skull+1
	clc
	adc     #$07
	bcc     L0004
	inx
L0004:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	sta     sreg
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L000A
	inx
L000A:	jsr     tosicmp
	jmi     L0003
	jeq     L0003
;
; Skull.x + 1 < paddle->x + paddle->width + paddle->bbox_x &&
;
	ldx     #$00
	lda     _Skull
	clc
	adc     #$01
	bcc     L0005
	inx
L0005:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     sreg
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L000B
	inx
L000B:	sta     sreg
	stx     sreg+1
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	clc
	adc     sreg
	ldx     sreg+1
	bcc     L000C
	inx
L000C:	jsr     tosicmp
	bpl     L0003
;
; Skull.y + 1 < paddle->y + paddle->height + paddle->bbox_y);
;
	ldx     #$00
	lda     _Skull+1
	clc
	adc     #$01
	bcc     L0006
	inx
L0006:	jsr     pushax
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	sta     sreg
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	iny
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     sreg
	bcc     L000D
	inx
L000D:	sta     sreg
	stx     sreg+1
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	lda     (ptr1),y
	clc
	adc     sreg
	ldx     sreg+1
	bcc     L000E
	inx
L000E:	jsr     tosicmp
	bmi     L0007
L0003:	ldx     #$00
	txa
	jmp     L000F
L0007:	lda     #$01
	ldx     #$00
;
; }
;
L000F:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ move_paddle (struct $anon-struct-0001 *paddle)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_move_paddle: near

.segment	"CODE"

;
; void move_paddle(Actor* paddle) {
;
	jsr     pushax
;
; temp_x = paddle->x + get_x_speed(paddle);
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _get_x_speed
	jsr     tosaddax
	sta     _temp_x
;
; temp_y = paddle->y + get_y_speed(paddle);
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	iny
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _get_y_speed
	jsr     tosaddax
	sta     _temp_y
;
; if (paddle->xDir == LEFT) {
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$08
	jsr     ldaidx
	cmp     #$FF
	bne     L0009
;
; while (get_collision_type(temp_x, temp_y)) {
;
	jmp     L0005
;
; ++temp_x;
;
L0003:	inc     _temp_x
;
; while (get_collision_type(temp_x, temp_y)) {
;
L0005:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L0003
;
; } else {
;
	jmp     L0008
;
; --temp_x;
;
L0007:	dec     _temp_x
;
; while (get_collision_type(temp_x + paddle->width, temp_y)) {
;
L0009:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	clc
	adc     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L0007
;
; if (paddle->yDir == UP) {
;
L0008:	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$09
	jsr     ldaidx
	cmp     #$FF
	bne     L0011
;
; while (get_collision_type(temp_x, temp_y)) {
;
	jmp     L000D
;
; ++temp_y;
;
L000B:	inc     _temp_y
;
; while (get_collision_type(temp_x, temp_y)) {
;
L000D:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L000B
;
; } else {
;
	jmp     L0010
;
; --temp_y;
;
L000F:	dec     _temp_y
;
; while (get_collision_type(temp_x, temp_y + paddle->height)) {
;
L0011:	lda     _temp_x
	jsr     pusha
	ldy     #$02
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	clc
	adc     _temp_y
	jsr     _get_collision_type
	tax
	bne     L000F
;
; paddle->x = temp_x;
;
L0010:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     _temp_x
	sta     (ptr1),y
;
; paddle->y = temp_y;
;
	iny
	lda     (sp),y
	sta     ptr1+1
	lda     (sp,x)
	sta     ptr1
	lda     _temp_y
	ldy     #$01
	sta     (ptr1),y
;
; if (pad1 & 0b00001111 && is_paddle_collision_skull(paddle)) {
;
	lda     _pad1
	and     #$0F
	beq     L001C
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _is_paddle_collision_skull
	tax
	beq     L0012
;
; Skull.xVelocity = 80;
;
	lda     #$50
	sta     _Skull+14
;
; if (paddle->xSpeedFloat > 0) {
;
L0012:	ldy     #$01
L001C:	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0A
	lda     (ptr1),y
	beq     L0016
;
; subtract_x_speed(16, paddle);
;
	lda     #$10
	jsr     pusha
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _subtract_x_speed
;
; if (paddle->ySpeedFloat > 0) {
;
L0016:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0B
	lda     (ptr1),y
	beq     L0017
;
; subtract_y_speed(16, paddle);
;
	lda     #$10
	jsr     pusha
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _subtract_y_speed
;
; }
;
L0017:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ check_paddle_collision (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_check_paddle_collision: near

.segment	"CODE"

;
; for (i = 0; i < paddle_count; ++i) {
;
	lda     #$00
	sta     _i
L0045:	lda     _i
	cmp     _paddle_count
	bcc     L004F
;
; }
;
	rts
;
; if (i < 2) {
;
L004F:	cmp     #$02
	jcs     L004C
;
; if (is_skull_collision_paddle(&paddles[i])) {
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _is_skull_collision_paddle
	tax
	jeq     L004C
;
; if (Skull.y + Skull.bbox_y < paddles[i].y + paddles[i].height + paddles[i].bbox_y && Skull.y + Skull.bbox_y + Skull.height > paddles[i].y + paddles[i].bbox_y) {
;
	ldx     #$00
	lda     _Skull+1
	clc
	adc     _Skull+5
	bcc     L003B
	inx
L003B:	jsr     pushax
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$03
	lda     (ptr1),y
	jsr     tosadda0
	jsr     pushax
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$05
	lda     (ptr1),y
	jsr     tosadda0
	jsr     tosicmp
	bpl     L0009
	ldx     #$00
	lda     _Skull+1
	clc
	adc     _Skull+5
	bcc     L0042
	inx
	clc
L0042:	adc     _Skull+3
	bcc     L003D
	inx
L003D:	jsr     pushax
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$05
	lda     (ptr1),y
	jsr     tosadda0
	jsr     tosicmp
	beq     L0009
	bpl     L000A
L0009:	jmp     L0049
;
; Skull.xSpeedFloat = 150;
;
L000A:	lda     #$96
	sta     _Skull+10
;
; Skull.ySpeedFloat = 50;
;
	lda     #$32
	sta     _Skull+11
;
; if (temp_x < paddles[i].x + (paddles[i].width >> 1)) {
;
	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$02
	lda     (ptr1),y
	lsr     a
	jsr     tosadda0
	jsr     tosicmp
	bpl     L000C
;
; xCollisionDir = RIGHT;
;
	lda     #$01
	sta     _xCollisionDir
;
; temp_x = paddles[i].x - Skull.width;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	sec
	sbc     _Skull+2
	sta     _temp_x
;
; while (get_collision_type(temp_x, temp_y)) {
;
	jmp     L0046
;
; ++temp_x;
;
L000D:	inc     _temp_x
;
; ++paddles[i].x;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$00
	lda     #$01
	clc
	adc     (ptr1),y
	sta     (ptr1),y
;
; while (get_collision_type(temp_x, temp_y)) {
;
L0046:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L000D
;
; } else {
;
	jmp     L0048
;
; xCollisionDir = LEFT;
;
L000C:	lda     #$FF
	sta     _xCollisionDir
;
; temp_x = paddles[i].x + paddles[i].width;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$02
	lda     (ptr1),y
	jsr     tosadda0
	sta     _temp_x
;
; while (get_collision_type(temp_x + Skull.width - 1, temp_y)) {
;
	jmp     L0047
;
; --temp_x;
;
L0011:	dec     _temp_x
;
; --paddles[i].x;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; while (get_collision_type(temp_x + Skull.width - 1, temp_y)) {
;
L0047:	lda     _temp_x
	clc
	adc     _Skull+2
	sec
	sbc     #$01
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L0011
;
; xCollisionDir = DOWN;
;
L0048:	lda     #$01
	sta     _xCollisionDir
;
; } else {
;
	jmp     L004C
;
; if (temp_x < paddles[i].x + (paddles[i].width >> 1)) {
;
L0049:	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$02
	lda     (ptr1),y
	lsr     a
	jsr     tosadda0
	jsr     tosicmp
	jpl     L0016
;
; if (temp_x <= paddles[i].x + 4) {
;
	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     #$04
	bcc     L0018
	inx
L0018:	jsr     tosicmp
	beq     L0043
	bpl     L0017
;
; if (Skull.xDir == RIGHT) {
;
L0043:	lda     _Skull+8
	cmp     #$01
	bne     L0019
;
; xCollisionDir = RIGHT;
;
	sta     _xCollisionDir
;
; Skull.xSpeedFloat = 140;
;
L0019:	lda     #$8C
	sta     _Skull+10
;
; Skull.ySpeedFloat = 60;
;
	lda     #$3C
;
; } else if (temp_x <= paddles[i].x + 8) {
;
	jmp     L003F
L0017:	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	ldx     #$00
	lda     (ptr1),y
	clc
	adc     #$08
	bcc     L001D
	inx
L001D:	jsr     tosicmp
	beq     L0044
	jpl     L0027
;
; if (Skull.xDir == RIGHT) {
;
L0044:	lda     _Skull+8
	cmp     #$01
	bne     L001E
;
; xCollisionDir = RIGHT;
;
	sta     _xCollisionDir
;
; Skull.xSpeedFloat = 100;
;
L001E:	lda     #$64
	sta     _Skull+10
;
; } else {
;
	jmp     L003F
;
; if (temp_x >= paddles[i].x + paddles[i].width - 4) {
;
L0016:	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$02
	lda     (ptr1),y
	jsr     tosadda0
	sec
	sbc     #$04
	bcs     L0023
	dex
L0023:	jsr     tosicmp
	bmi     L0022
;
; if (Skull.xDir == LEFT) {
;
	lda     _Skull+8
	cmp     #$FF
	bne     L0024
;
; xCollisionDir = LEFT;
;
	sta     _xCollisionDir
;
; Skull.xSpeedFloat = 140;
;
L0024:	lda     #$8C
	sta     _Skull+10
;
; Skull.ySpeedFloat = 60;
;
	lda     #$3C
;
; } else if (temp_x >= paddles[i].x + paddles[i].width - 8) {
;
	jmp     L003F
L0022:	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$02
	lda     (ptr1),y
	jsr     tosadda0
	sec
	sbc     #$08
	bcs     L0028
	dex
L0028:	jsr     tosicmp
	bmi     L0027
;
; if (Skull.xDir == LEFT) {
;
	lda     _Skull+8
	cmp     #$FF
	bne     L0029
;
; xCollisionDir = LEFT;
;
	sta     _xCollisionDir
;
; Skull.xSpeedFloat = 100;
;
L0029:	lda     #$64
	sta     _Skull+10
;
; } else {
;
	jmp     L003F
;
; Skull.xSpeedFloat = 60;
;
L0027:	lda     #$3C
	sta     _Skull+10
;
; Skull.ySpeedFloat = 140;
;
	lda     #$8C
L003F:	sta     _Skull+11
;
; if (temp_y < paddles[i].y + paddles[i].bbox_y + (paddles[i].height >> 1)) {
;
	lda     _temp_y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$05
	lda     (ptr1),y
	jsr     tosadda0
	jsr     pushax
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$03
	lda     (ptr1),y
	lsr     a
	jsr     tosadda0
	jsr     tosicmp
	jpl     L002C
;
; yCollisionDir = DOWN;
;
	lda     #$01
	sta     _yCollisionDir
;
; while (is_skull_collision_paddle(&paddles[i])) {
;
	jmp     L004A
;
; --temp_y;
;
L002D:	dec     _temp_y
;
; if (get_collision_type(temp_x, temp_y)) {
;
	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	beq     L004A
;
; ++temp_y;
;
	inc     _temp_y
;
; temp_x < paddles[i].x + (paddles[i].width >> 1) ? --temp_x : ++temp_x;
;
	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$02
	lda     (ptr1),y
	lsr     a
	jsr     tosadda0
	jsr     tosicmp
	bpl     L0031
	dec     _temp_x
	jmp     L004A
L0031:	inc     _temp_x
;
; while (is_skull_collision_paddle(&paddles[i])) {
;
L004A:	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _is_skull_collision_paddle
	tax
	bne     L002D
;
; } else {
;
	jmp     L004C
;
; yCollisionDir = UP;
;
L002C:	lda     #$FF
	sta     _yCollisionDir
;
; while (is_skull_collision_paddle(&paddles[i])) {
;
	jmp     L004B
;
; ++temp_y;
;
L0034:	inc     _temp_y
;
; if (get_collision_type(temp_x, temp_y)) {
;
	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	beq     L004B
;
; --temp_y;
;
	dec     _temp_y
;
; temp_x < paddles[i].x + (paddles[i].width >> 1) ? --temp_x : ++temp_x;
;
	lda     _temp_x
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$02
	lda     (ptr1),y
	lsr     a
	jsr     tosadda0
	jsr     tosicmp
	bpl     L0038
	dec     _temp_x
	jmp     L004B
L0038:	inc     _temp_x
;
; while (is_skull_collision_paddle(&paddles[i])) {
;
L004B:	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _is_skull_collision_paddle
	tax
	bne     L0034
;
; for (i = 0; i < paddle_count; ++i) {
;
L004C:	inc     _i
	jmp     L0045

.endproc

; ---------------------------------------------------------------
; void __near__ check_main_input (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_check_main_input: near

.segment	"CODE"

;
; for (i = 0; i < paddle_count; ++i) {
;
	lda     #$00
	sta     _i
L0014:	lda     _i
	cmp     _paddle_count
	jcs     L0019
;
; if (!is_paddle_collision_skull(&paddles[i])) {
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _is_paddle_collision_skull
	tax
	jne     L0004
;
; if (i < 2) {
;
	lda     _i
	cmp     #$02
	jcs     L0016
;
; if (pad1 & PAD_LEFT) {
;
	lda     _pad1
	and     #$02
	beq     L0015
;
; add_x_speed(80, &paddles[i]);
;
	lda     #$50
	jsr     pusha
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _add_x_speed
;
; paddles[i].xDir = LEFT;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$FF
	ldy     #$08
	sta     (ptr1),y
;
; if (pad1 & PAD_RIGHT) {
;
L0015:	lda     _pad1
	and     #$01
	jeq     L0018
;
; add_x_speed(80, &paddles[i]);
;
	lda     #$50
	jsr     pusha
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _add_x_speed
;
; paddles[i].xDir = RIGHT;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$01
	ldy     #$08
;
; } else {
;
	jmp     L0013
;
; if (pad1 & PAD_UP) {
;
L0016:	lda     _pad1
	and     #$08
	beq     L0017
;
; add_y_speed(80, &paddles[i]);
;
	lda     #$50
	jsr     pusha
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _add_y_speed
;
; paddles[i].yDir = UP;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$FF
	ldy     #$09
	sta     (ptr1),y
;
; if (pad1 & PAD_DOWN) {
;
L0017:	lda     _pad1
	and     #$04
	beq     L0018
;
; add_y_speed(80, &paddles[i]);
;
	lda     #$50
	jsr     pusha
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _add_y_speed
;
; paddles[i].yDir = DOWN;
;
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	lda     #$01
	ldy     #$09
L0013:	sta     (ptr1),y
;
; move_paddle(&paddles[i]);
;
L0018:	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	tay
	txa
	adc     #>(_paddles)
	tax
	tya
	jsr     _move_paddle
;
; for (i = 0; i < paddle_count; ++i) {
;
L0004:	inc     _i
	jmp     L0014
;
; if (pad1 & PAD_A) {
;
L0019:	lda     _pad1
	and     #$80
	beq     L001B
;
; if (skull_launched) {
;
	lda     _skull_launched
	beq     L001A
;
; add_x_speed(SPEED_STEP, &Skull);
;
	lda     #$01
	jsr     pusha
	lda     #<(_Skull)
	ldx     #>(_Skull)
	jsr     _add_x_speed
;
; } else {
;
	jmp     L001B
;
; skull_launched = TRUE;
;
L001A:	lda     #$01
	sta     _skull_launched
;
; if (pad1 & PAD_B) {
;
L001B:	lda     _pad1
	and     #$40
	beq     L001C
;
; subtract_x_speed(SPEED_STEP, &Skull);
;
	lda     #$01
	jsr     pusha
	lda     #<(_Skull)
	ldx     #>(_Skull)
	jsr     _subtract_x_speed
;
; if (pad1 & PAD_START) {
;
L001C:	lda     _pad1
	ldx     #$00
	and     #$10
	stx     tmp1
	ora     tmp1
;
; if (pad1 & PAD_SELECT) {
;
	lda     _pad1
	and     #$20
	ora     tmp1
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ update_skull (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_skull: near

.segment	"CODE"

;
; xCollisionDir = NONE;
;
	lda     #$00
	sta     _xCollisionDir
;
; yCollisionDir = NONE;
;
	sta     _yCollisionDir
;
; backup_col_type = NONE;
;
	sta     _backup_col_type
;
; is_soft_hit = FALSE;
;
	tax
	sta     _is_soft_hit
;
; if (skull_launched) {
;
	lda     _skull_launched
	jeq     L0094
;
; temp_x = Skull.x + get_x_speed(&Skull);
;
	lda     _Skull
	jsr     pusha0
	lda     #<(_Skull)
	ldx     #>(_Skull)
	jsr     _get_x_speed
	jsr     tosaddax
	sta     _temp_x
;
; temp_y = Skull.y + get_y_speed(&Skull);
;
	lda     _Skull+1
	jsr     pusha0
	lda     #<(_Skull)
	ldx     #>(_Skull)
	jsr     _get_y_speed
	jsr     tosaddax
	sta     _temp_y
;
; ++temp_x;
;
	inc     _temp_x
;
; ++temp_y;
;
	inc     _temp_y
;
; if (Skull.xDir == RIGHT) {
;
	lda     _Skull+8
	cmp     #$01
	jne     L0003
;
; if (Skull.yDir == DOWN) {
;
	lda     _Skull+9
	cmp     #$01
	jne     L0005
;
; if (set_collision_data(temp_x, temp_y + Skull.height)) {
;
	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _set_collision_data
	tax
	beq     L006F
;
; yCollisionDir = DOWN;
;
	lda     #$01
	sta     _yCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	beq     L000A
;
; while (get_collision_type(temp_x, temp_y + Skull.height)) {
;
	jmp     L006E
;
; --temp_y;
;
L0009:	dec     _temp_y
;
; while (get_collision_type(temp_x, temp_y + Skull.height)) {
;
L006E:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _get_collision_type
	tax
	bne     L0009
;
; do_skull_tile_collision();
;
L000A:	jsr     _do_skull_tile_collision
;
; if (set_collision_data(temp_x + Skull.width, temp_y) || (backup_col_type == 0 && set_collision_data(temp_x + Skull.width, temp_y + Skull.height))) {
;
L006F:	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	jsr     _set_collision_data
	tax
	bne     L000D
	lda     _backup_col_type
	jne     L003E
	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _set_collision_data
	tax
	jeq     L003E
;
; xCollisionDir = RIGHT;
;
L000D:	lda     #$01
	sta     _xCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	jeq     L0046
;
; while (get_collision_type(temp_x + Skull.width, temp_y)) {
;
	jmp     L0077
;
; --temp_x;
;
L0013:	dec     _temp_x
;
; while (get_collision_type(temp_x + Skull.width, temp_y)) {
;
L0077:	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L0013
;
; } else {
;
	jmp     L0046
;
; if (set_collision_data(temp_x, temp_y)) {
;
L0005:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _set_collision_data
	tax
	beq     L0079
;
; yCollisionDir = UP;
;
	lda     #$FF
	sta     _yCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	beq     L001A
;
; while (get_collision_type(temp_x, temp_y)) {
;
	jmp     L0078
;
; ++temp_y;
;
L0019:	inc     _temp_y
;
; while (get_collision_type(temp_x, temp_y)) {
;
L0078:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L0019
;
; do_skull_tile_collision();
;
L001A:	jsr     _do_skull_tile_collision
;
; if (set_collision_data(temp_x + Skull.width, temp_y + Skull.height) || (backup_col_type == 0 && set_collision_data(temp_x + Skull.width, temp_y))) {
;
L0079:	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _set_collision_data
	tax
	bne     L001D
	lda     _backup_col_type
	jne     L003E
	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	jsr     _set_collision_data
	tax
	jeq     L003E
;
; xCollisionDir = RIGHT;
;
L001D:	lda     #$01
	sta     _xCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	jeq     L0046
;
; while (get_collision_type(temp_x + Skull.width, temp_y + Skull.height)) {
;
	jmp     L0081
;
; --temp_x;
;
L0023:	dec     _temp_x
;
; while (get_collision_type(temp_x + Skull.width, temp_y + Skull.height)) {
;
L0081:	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _get_collision_type
	tax
	bne     L0023
;
; } else {
;
	jmp     L0046
;
; if (Skull.yDir == DOWN) {
;
L0003:	lda     _Skull+9
	cmp     #$01
	jne     L0027
;
; if (set_collision_data(temp_x + Skull.width, temp_y + Skull.height)) {
;
	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _set_collision_data
	tax
	beq     L0083
;
; yCollisionDir = DOWN;
;
	lda     #$01
	sta     _yCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	beq     L002C
;
; while (get_collision_type(temp_x + Skull.width, temp_y + Skull.height)) {
;
	jmp     L0082
;
; --temp_y;
;
L002B:	dec     _temp_y
;
; while (get_collision_type(temp_x + Skull.width, temp_y + Skull.height)) {
;
L0082:	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _get_collision_type
	tax
	bne     L002B
;
; do_skull_tile_collision();
;
L002C:	jsr     _do_skull_tile_collision
;
; if (set_collision_data(temp_x, temp_y) || (backup_col_type == 0 && set_collision_data(temp_x, temp_y + Skull.height))) {
;
L0083:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _set_collision_data
	tax
	bne     L0088
	lda     _backup_col_type
	jne     L003E
	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _set_collision_data
	tax
	jeq     L003E
;
; xCollisionDir = LEFT;
;
L0088:	lda     #$FF
	sta     _xCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	jeq     L0046
;
; while (get_collision_type(temp_x, temp_y)) {
;
	jmp     L0089
;
; ++temp_x;
;
L0035:	inc     _temp_x
;
; while (get_collision_type(temp_x, temp_y)) {
;
L0089:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L0035
;
; } else {
;
	jmp     L0046
;
; if (set_collision_data(temp_x + Skull.width, temp_y)) {
;
L0027:	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	jsr     _set_collision_data
	tax
	beq     L008B
;
; yCollisionDir = UP;
;
	lda     #$FF
	sta     _yCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	beq     L003C
;
; while (get_collision_type(temp_x + Skull.width, temp_y)) {
;
	jmp     L008A
;
; ++temp_y;
;
L003B:	inc     _temp_y
;
; while (get_collision_type(temp_x + Skull.width, temp_y)) {
;
L008A:	lda     _temp_x
	clc
	adc     _Skull+2
	jsr     pusha
	lda     _temp_y
	jsr     _get_collision_type
	tax
	bne     L003B
;
; do_skull_tile_collision();
;
L003C:	jsr     _do_skull_tile_collision
;
; if (set_collision_data(temp_x, temp_y + Skull.height) || (backup_col_type == 0 && set_collision_data(temp_x, temp_y))) {
;
L008B:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _set_collision_data
	tax
	bne     L0090
	lda     _backup_col_type
	bne     L003E
	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	jsr     _set_collision_data
	tax
	beq     L003E
;
; xCollisionDir = LEFT;
;
L0090:	lda     #$FF
	sta     _xCollisionDir
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	beq     L0046
;
; while (get_collision_type(temp_x, temp_y + Skull.height)) {
;
	jmp     L0091
;
; ++temp_x;
;
L0045:	inc     _temp_x
;
; while (get_collision_type(temp_x, temp_y + Skull.height)) {
;
L0091:	lda     _temp_x
	jsr     pusha
	lda     _temp_y
	clc
	adc     _Skull+3
	jsr     _get_collision_type
	tax
	bne     L0045
;
; do_skull_tile_collision();
;
L0046:	jsr     _do_skull_tile_collision
;
; check_paddle_collision();
;
L003E:	jsr     _check_paddle_collision
;
; if (backup_col_type != COL_TYPE_SOFT) {
;
	lda     _backup_col_type
	cmp     #$06
	beq     L0092
;
; if (xCollisionDir) {
;
	lda     _xCollisionDir
	beq     L0049
;
; Skull.xSpeed = -Skull.xSpeed;
;
	lda     _Skull+6
	eor     #$FF
	clc
	adc     #$01
	cmp     #$80
	sta     _Skull+6
;
; Skull.xDir = -Skull.xDir;
;
	lda     _Skull+8
	eor     #$FF
	clc
	adc     #$01
	cmp     #$80
	sta     _Skull+8
;
; if (yCollisionDir) {
;
L0049:	lda     _yCollisionDir
	beq     L0092
;
; Skull.ySpeed = -Skull.ySpeed;
;
	lda     _Skull+7
	eor     #$FF
	clc
	adc     #$01
	cmp     #$80
	sta     _Skull+7
;
; Skull.yDir = -Skull.yDir;
;
	lda     _Skull+9
	eor     #$FF
	clc
	adc     #$01
	cmp     #$80
	sta     _Skull+9
;
; --temp_x;
;
L0092:	dec     _temp_x
;
; --temp_y;
;
	dec     _temp_y
;
; } else {
;
	jmp     L0095
;
; temp_x = paddles[0].x + (paddles[0].width >> 1) - (Skull.width >> 1);
;
L0094:	lda     _paddles+2
	lsr     a
	clc
	adc     _paddles
	bcc     L0069
	inx
L0069:	jsr     pushax
	lda     _Skull+2
	lsr     a
	jsr     tossuba0
	sta     _temp_x
;
; temp_y = paddles[0].y + paddles[0].bbox_y - Skull.height - Skull.bbox_x;
;
	lda     _paddles+1
	clc
	adc     _paddles+5
	sec
	sbc     _Skull+3
	sec
	sbc     _Skull+4
	sta     _temp_y
;
; Skull.x = temp_x;
;
L0095:	lda     _temp_x
	sta     _Skull
;
; Skull.y = temp_y;
;
	lda     _temp_y
	sta     _Skull+1
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; for (i = 0; i < paddle_count; ++i) {
;
	lda     #$00
	sta     _i
L0009:	lda     _i
	cmp     _paddle_count
	jcs     L0003
;
; if (i < 2) {
;
	cmp     #$02
	bcs     L0006
;
; oam_meta_spr(paddles[i].x, paddles[i].y, HorizontalPaddleSpr);
;
	jsr     decsp2
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	ldy     #$01
	sta     (sp),y
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	dey
	sta     (sp),y
	lda     #<(_HorizontalPaddleSpr)
	ldx     #>(_HorizontalPaddleSpr)
;
; } else {
;
	jmp     L0008
;
; oam_meta_spr(paddles[i].x, paddles[i].y, VerticalPaddleSpr);
;
L0006:	jsr     decsp2
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	sta     ptr1
	txa
	clc
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #<(_paddles)
	lda     (ptr1),y
	ldy     #$01
	sta     (sp),y
	lda     _i
	jsr     pusha0
	lda     #$12
	jsr     tosmula0
	clc
	adc     #<(_paddles)
	sta     ptr1
	txa
	adc     #>(_paddles)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	dey
	sta     (sp),y
	lda     #<(_VerticalPaddleSpr)
	ldx     #>(_VerticalPaddleSpr)
L0008:	jsr     _oam_meta_spr
;
; for (i = 0; i < paddle_count; ++i) {
;
	inc     _i
	jmp     L0009
;
; oam_meta_spr(Skull.x, Skull.y, SkullSpr);
;
L0003:	jsr     decsp2
	lda     _Skull
	ldy     #$01
	sta     (sp),y
	lda     _Skull+1
	dey
	sta     (sp),y
	lda     #<(_SkullSpr)
	ldx     #>(_SkullSpr)
	jmp     _oam_meta_spr

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; load_title_screen();
;
	jsr     _load_title_screen
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; while (game_state == TITLE) {
;
	jmp     L000C
;
; ppu_wait_nmi();
;
L0005:	jsr     _ppu_wait_nmi
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0);
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; if (pad1_new & PAD_START) {
;
	and     #$10
	beq     L000C
;
; game_state = MAIN;
;
	lda     #$01
	sta     _game_state
;
; current_level = 0;
;
	lda     #$00
	sta     _current_level
;
; p1_health = 3;
;
	lda     #$03
	sta     _p1_health
;
; p1_max_health = 3;
;
	sta     _p1_max_health
;
; load_level();
;
	jsr     _load_level
;
; while (game_state == TITLE) {
;
L000C:	lda     _game_state
	beq     L0005
;
; while (game_state == MAIN) {
;
	jmp     L000D
;
; ppu_wait_nmi();
;
L0009:	jsr     _ppu_wait_nmi
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0);
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; check_main_input();
;
	jsr     _check_main_input
;
; update_skull();
;
	jsr     _update_skull
;
; draw_sprites();
;
	jsr     _draw_sprites
;
; while (game_state == MAIN) {
;
L000D:	lda     _game_state
	cmp     #$01
	beq     L0009
;
; while (1) {
;
	jmp     L000C

.endproc

